from typing import Dict, Any
from pathlib import Path
import subprocess

from orchestrator.agents.base import Agent
from orchestrator.ctb import CTB
from orchestrator.guard import ensure_guarded_write
from orchestrator.db import create_artifact

class BEAgent(Agent):
    """Backend Agent: Implements APIs and business logic."""
    ROLE = "BE"

    def __init__(self, llm):
        super().__init__(llm)

    async def run(self, ctb: CTB) -> Dict[str, Any]:
        self._log(ctb, "INFO", f"Starting backend task: {ctb.objective}")

        # 1. Xác định file code cần tạo/sửa
        # Đây là một ví dụ đơn giản, trong thực tế có thể phức tạp hơn
        target_file_path = f"workspace/src/api/{ctb.story_id.lower()}_routes.py"

        # 2. Lấy system prompt từ file
        try:
            with open(f"agent_framework/orchestrator/prompts/{self.ROLE.lower()}.system.txt", "r") as f:
                system_prompt = f.read()
        except FileNotFoundError:
            system_prompt = "You are the Backend Agent. Your goal is to implement APIs."

        # 3. Tạo user prompt cho LLM, bao gồm đầy đủ attachments
        user_prompt = (
            f"You are the Backend Agent. Please generate the Python code for the file '{target_file_path}' using FastAPI.\n\n"
            f"### OBJECTIVE ###\n{ctb.objective}\n\n"
            f"### CONSTRAINTS ###\n{ctb.constraints}\n- Add docstrings to all public functions.\n- Use small, pure functions where possible.\n- Do not hardcode any secrets.\n\n"
            f"### ACCEPTANCE CRITERIA ###\n{ctb.acceptance}\n\n"
            f"### ATTACHMENTS ###\n--- AGENTS.MD ---\n{ctb.attachments.get('AGENTS.MD', 'N/A')}\n\n"
            f"--- BACKLOG.MD ---\n{ctb.attachments.get('BACKLOG.md', 'N/A')}\n\n"
            f"--- CURRENT ROOM DOC ---\n{ctb.attachments.get('ROOM.md', 'N/A')}"
        )

        # 4. Gọi LLM để lấy code
        self._log(ctb, "INFO", f"Calling LLM to generate code for '{target_file_path}'.")
        code_content = await self.llm.complete(
            role=self.ROLE,
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            task_id=ctb.task_id,
            story_id=ctb.story_id
        )

        # 5. Ghi file code một cách an toàn
        try:
            guarded_path = ensure_guarded_write(
                guard_patterns=ctb.guard_paths,
                root=".",
                write_path=target_file_path
            )
            
            Path(guarded_path).parent.mkdir(parents=True, exist_ok=True)
            Path(guarded_path).write_text(f"# Generated by {self.ROLE} Agent for task {ctb.task_id}\n\n" + code_content)
            
            self._log(ctb, "INFO", "Successfully wrote code artifact.", meta={"path": str(guarded_path)})
            
            self._log(ctb, "INFO", "Running quality checks (lint, type-check, tests)...")
            checks = [
                ("Lint", ["bash", "agent_framework/tools/run_lint.sh"]),
                ("Typecheck", ["bash", "agent_framework/tools/run_typecheck.sh"]),
                ("Tests", ["bash", "agent_framework/tools/run_tests.sh"])
            ]

            for label, command in checks:
                result = subprocess.run(command, capture_output=True, text=True)
                if result.returncode != 0:
                    stdout = result.stdout or ""
                    stderr = result.stderr or ""
                    if label == "Tests" and "No test runner configured" in stdout:
                        self._log(ctb, "WARN", "Tests skipped: No test runner configured.", meta={"stdout": stdout[-1000:], "stderr": stderr[-1000:]})
                        continue
                    self._log(ctb, "ERROR", f"{label} script failed.", meta={"stdout": stdout[-1000:], "stderr": stderr[-1000:]})
                    return {"status": "Failed", "error": f"{label} check failed"}
                else:
                    self._log(ctb, "INFO", f"{label} check passed.", meta={"stdout": (result.stdout or "")[-1000:]})

            create_artifact(ctb.story_id, ctb.task_id, str(guarded_path), "code")
            self._log(ctb, "INFO", "All quality checks passed and artifact registered.")

            return {"status": "Coding Complete", "artifacts": [str(guarded_path)]}
        except PermissionError as e:
            self._log(ctb, "ERROR", f"File write permission error: {e}")
            return {"status": "Failed", "error": str(e)}
        except Exception as e:
            self._log(ctb, "ERROR", f"Unknown error while writing file: {e}")
            return {"status": "Failed", "error": str(e)}
